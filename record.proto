import * as fs from 'fs';
import * as path from 'path';
import * as glob from 'glob';
import * as os from 'os';
import { readCsv } from './fileManager';
const csv = require('csvtojson');
const Exceljs = require('exceljs');

// ---------- helpers to keep Excel happy ----------
function getCellString(cell: any): string {
  const v = cell?.value;
  if (v == null) return "";
  if (typeof v === "string" || typeof v === "number") return String(v);
  if (typeof v === "object") {
    if ("result" in v && v.result != null) return String((v as any).result);
    if ("text" in v && (v as any).text != null) return String((v as any).text);
    if ("richText" in v && Array.isArray((v as any).richText)) {
      return (v as any).richText.map((t: any) => t.text ?? "").join("");
    }
  }
  return "";
}

function toNumberish(val: string | number, fallback = 0): number {
  if (typeof val === "number") return Number.isFinite(val) ? val : fallback;
  const cleaned = String(val).replace(/[^0-9.\-]/g, "");
  if (cleaned === "") return fallback;
  const n = Number(cleaned);
  return Number.isFinite(n) ? n : fallback;
}
// --------------------------------------------------

export async function combineAndExport(fullPathOut) {
  const grps = await getFilePathGroups(fullPathOut);
  let flatFilePath;
  // for each zip grouping (ie for each zipcode) files are combined and written as one flat csv file per zip
  for (const g of Object.keys(grps)) {
    let flattenedZipDataObjects = await flattenFileGroup(grps[g]);
    flatFilePath = await writeToFile(g, flattenedZipDataObjects);
    let fileName = g;
    let zip = fileName.split("_")[0];
    await outputToExcel(fullPathOut, fileName, flatFilePath, zip, flattenedZipDataObjects);
  }
}

export function testHeaders(flattenedZipDataObjects) {
  const lengths = flattenedZipDataObjects.map(obj => obj.length).flat();
  const distinctLengths = new Set(lengths);
  if (distinctLengths.size !== 1) {
    throw 'Unexpected plans and pharmacy counts found. Some drugs may have missing drug costs for a plan or pharmacy.';
  }
  const distinctHeaders = new Set();
  flattenedZipDataObjects.forEach(obj => distinctHeaders.add(obj.map(row => row[0]).join(',')));
  if (distinctHeaders.size !== 1) {
    throw 'Unexpected set of headers found. Some drugs may have missing drug costs for a plan or pharmacy.';
  }
}

export async function writeToFile(fileName, flattenedZipDataObjects) {
  const reportFile = path.join(__dirname, `../../../output/${fileName}_flat.csv`);
  console.log(`Working on file: ${fileName}`);
  try { fs.unlinkSync(reportFile); } catch (e) { }

  // testHeaders(flattenedZipDataObjects)

  let header = `${flattenedZipDataObjects[0].map(row => row[0]).join(',')}\n`;
  let lines = [header];
  for (const line of flattenedZipDataObjects) {
    let fullLine = line.map(row => {
      // remove comma from subelement to prevent them from accidentally being used as a delimiter
      return row[1].toString().replace(/,/g, '');
    }).join(',');
    lines.push(`${fullLine}\n`);
  }
  lines.forEach(ln => {
    fs.appendFileSync(reportFile, ln);
  });
  return reportFile;
}

// each zipcode may have multiple seperate files, this function creates a dictionary that groups the filepaths of those sep files by zip to be iterated on later
export async function getFilePathGroups(fullPathOut) {
  let pattern = `${fullPathOut}/*.csv`;
  const csvDataFiles = glob.sync(pattern);

  let testStr;
  let parts = [];
  let groupGlobs = [];
  csvDataFiles.forEach(nm => {
    parts = path.basename(nm).split('_');
    // if no indices provided, split on _ will give something like esrd.csv for parts[1], so replace the .csv part
    testStr = `${parts[0]}`;
    if (groupGlobs.indexOf(testStr) < 0) {
      groupGlobs.push(testStr);
    }
  });
  let groupedFiles: Record<string, string[]> = {};
  groupGlobs.forEach(glb => {
    pattern = `${fullPathOut}/${glb}*.csv`;
    // sort and rank of the drug output
    groupedFiles[glb] = glob.sync(pattern).sort((a, b) => a.localeCompare(b, undefined, { numeric: true }));
  });

  console.log("Grouped Files Detected:");
  console.log(groupedFiles);
  return groupedFiles;
}

//this function takes the filegroup list for each zip and flattens the file data and combines them and adds some header information
export async function flattenFileGroup(fileGroupList) {
  let planIdMap = {};
  let zipGroupSortedObjects = await combineAndSortFileGroupData(fileGroupList);
  let flattenedZipData = flattenZipData(zipGroupSortedObjects, planIdMap);
  return flattenedZipData;
}

export async function combineAndSortFileGroupData(fileGroupList) {
  let zipData: any[] = [];
  for (const fileName of fileGroupList) {
    let fileData = await readCsv(fileName);
    zipData.push(...fileData);
  }
  // Sort by drugCategory, drugName, planId, mail order last
  zipData.sort(function (a, b) {
    let exceptions = ["Mail order pharmacy"], indexA, indexB;
    indexA = exceptions.indexOf(a.source);
    indexB = exceptions.indexOf(b.source);
    let mail_order_calc = 0;
    if (indexA === -1 && indexB === -1) {
      mail_order_calc = a.source.toLowerCase().localeCompare(b.source.toLowerCase()); // regular case
    } else {
      mail_order_calc = indexA - indexB; // index will be -1 (doesn't occur), 0 or 1
    }
    return (
      a.drugCategory.localeCompare(b.drugCategory) ||
      a.brandGenericFlag.localeCompare(b.brandGenericFlag) ||
      a.rank - b.rank ||
      a.drugName.localeCompare(b.drugName) ||
      a.planId.localeCompare(b.planId) ||
      mail_order_calc
    );
  });

  return zipData;
}

export function flattenZipData(zipData, planIdMap) {
  let flattenedZipData: any[] = [];
  zipData.forEach(priceObjct => {
    let found = flattenedZipData.find(objct =>
      objct[0][1] == priceObjct.rank &&
      objct[1][1] == priceObjct.drugCategory &&
      objct[2][1] == priceObjct.drugName &&
      objct[3][1] == priceObjct.quantity
    );
    if (!!found) {
      found.push([`${priceObjct.planId}_${priceObjct.planName}_${priceObjct.source}`, priceObjct.cost]);
    } else {
      var flattenedObj = [
        [`Rank`, priceObjct.rank],
        ['Drug Category', priceObjct.drugCategory],
        ['Drug', priceObjct.drugName],
        ['Quantity', priceObjct.quantity],
        ['Refill Frequency', '30'],
        ['Package Option', priceObjct.packageOption],
        ['Brand or Generic', priceObjct.brandGenericFlag],
        [`${priceObjct.planId}_${priceObjct.planName}_${priceObjct.source}`, priceObjct.cost]
      ];
      flattenedZipData.push(flattenedObj);
    }
    planIdMap[`${priceObjct.planId}_${priceObjct.planName}_${priceObjct.source}`] = priceObjct.planId;
  });
  return flattenedZipData;
}

// this function takes a file and flattens the data (formatted to be put in csv format)
export async function flattenFile(filePath, orderOfPlans, orderOfSources, orderOfPlanIDs) {
  let currentDrug, currentCategory, currentRank, currentQty, currentRefillFreq, currentPackageOption, currentBorG;
  let planSourceObject = [];
  let planSourceObjects = [];
  let lines = [];
  await csv().fromFile(filePath).subscribe((lineData, rowNum) => {
    if (lineData.drugName != currentDrug) {
      if (rowNum > 0) {
        // add the completed line to the list
        lines.push(`${currentRank},${currentCategory},${currentDrug},${currentQty},${currentRefillFreq},${currentPackageOption},${currentBorG},${planSourceObjects.join()}\n`);
      }
      // reset loop state
      planSourceObject = [];
      planSourceObjects = [];
      currentDrug = lineData.drugName;
      currentRank = lineData.rank;
      currentCategory = lineData.drugCategory;
      currentQty = lineData.quantity;
      currentPackageOption = lineData.packageOption;
      currentBorG = lineData.brandGenericFlag;
      currentRefillFreq = "30";
    }
    if (!orderOfPlans.includes(lineData.planName)) {
      orderOfPlans.push(lineData.planName);
    }
    if (!orderOfSources.includes(lineData.source)) {
      orderOfSources.push(lineData.source);
    }

    if (!orderOfPlanIDs.includes(lineData.planId)) {
      orderOfPlanIDs.push(lineData.planId);
    }

    planSourceObject[orderOfSources.indexOf(lineData.source)] = lineData.cost;
    planSourceObjects[orderOfPlans.indexOf(lineData.planName)] = planSourceObject.slice();
  });

  // required for the last price line
  lines.push(`${currentRank},${currentCategory},${currentDrug},${currentQty},${currentRefillFreq},${currentPackageOption},${currentBorG},${planSourceObjects.join()}\n`);

  return lines;
}

export async function outputToExcel(fullPathOut, filename, flatFilePath, zipCode, flattenedZipDataObjects) {
  let xlfileName = path.join(fullPathOut, `${filename}_xl_file.xlsx`);

  //open a workbook
  let workbook = new Exceljs.Workbook();
  //add a sheet
  let worksheet = workbook.addWorksheet("New Sheet");

  // define columns from headers in first flattened object
  worksheet.columns = flattenedZipDataObjects[0].map(row => ({ header: row[0], key: row[0] }));

  // add 2 empty rows above header row
  worksheet.spliceRows(1, 0, []);
  worksheet.spliceRows(1, 0, []);

  // Insert all row data
  const rows: any[] = [];
  flattenedZipDataObjects.forEach(row => rows.push(row.map(data => data[1])));
  worksheet.addRows(rows);

  // default styling
  worksheet.properties.defaultColWidth = 10;
  worksheet.properties.defaultCellWidth = 10;
  worksheet.getRow(1).alignment = { vertical: 'middle', horizontal: 'left' };
  worksheet.getRow(2).alignment = { vertical: 'middle', horizontal: 'left' };
  worksheet.getRow(3).alignment = { vertical: 'middle', horizontal: 'left' };
  worksheet.getRow(1).height = 35;
  worksheet.getRow(2).height = 35;
  worksheet.getRow(3).height = 35;
  worksheet.getColumn(1).width = 8;
  worksheet.getColumn(2).width = 16;
  worksheet.getColumn(3).width = 35;
  worksheet.getColumn(4).width = 9;
  worksheet.getColumn(5).width = 16;
  worksheet.getColumn(6).width = 16;
  worksheet.getRow(1).font = { bold: true, size: 14 };
  worksheet.getRow(2).font = { bold: true, size: 12 };
  worksheet.getRow(3).font = { bold: true, size: 12 };
  worksheet.getRow(1).border = {
    top: { style: 'medium' },
    left: { style: 'medium' },
    bottom: { style: 'medium' },
    right: { style: 'medium' }
  };
  worksheet.getRow(2).border = {
    top: { style: 'medium' },
    left: { style: 'medium' },
    bottom: { style: 'medium' },
    right: { style: 'medium' }
  };
  worksheet.getColumn(7).border = {
    right: { style: 'medium' }
  };

  // Merge cells Date
  const zipAndDateCellRange = 'A1:G2';
  worksheet.mergeCells(zipAndDateCellRange);
  const today = new Date();
  const dateString = `${today.getFullYear()}-${('0' + (today.getMonth() + 1)).slice(-2)}-${('0' + today.getDate()).slice(-2)}`;
  worksheet.getCell('A2').value = `Zip Code: ${zipCode} \n Report Date: ${dateString}`;

  // Split planName, planId, and Pharmacy to their own cells
  let firstPlanColumnNum = 7; // 1-based column index where plans start
  const totalColumns = worksheet.columns.length;

  for (let colIdx = firstPlanColumnNum; colIdx <= totalColumns; colIdx++) {
    const thisColumn = worksheet.getColumn(colIdx);
    const keyStr = String(thisColumn.key ?? thisColumn.header ?? "");
    const splitColNm = keyStr.split('_');
    const planId = splitColNm[0] ?? "";
    const planName = splitColNm[1] ?? "";
    const pharmacyName = splitColNm[2] ?? "";

    worksheet.getCell(1, colIdx).value = `Plan Name: ${planName}`;
    worksheet.getCell(2, colIdx).value = `Plan Id: ${planId}`;
    worksheet.getCell(3, colIdx).value = pharmacyName;

    worksheet.getCell(1, colIdx).alignment = { vertical: 'middle', horizontal: 'center' };
    worksheet.getCell(2, colIdx).alignment = { vertical: 'middle', horizontal: 'center' };
    worksheet.getCell(3, colIdx).alignment = { vertical: 'middle', horizontal: 'center' };

    worksheet.getColumn(colIdx).width = 30; // set width on the column (not the cell)
  }

  // Merge cells row 1 and row 2 for plans (group of pharmacies under each plan)
  firstPlanColumnNum = 8;
  let mergeSpan = 7;
  let currentColumnNum = firstPlanColumnNum;
  let lastColumnNumber = totalColumns;
  while (currentColumnNum + mergeSpan <= lastColumnNumber) {
    worksheet.mergeCells(1, currentColumnNum, 1, currentColumnNum + mergeSpan);
    worksheet.mergeCells(2, currentColumnNum, 2, currentColumnNum + mergeSpan);
    currentColumnNum = currentColumnNum + mergeSpan + 1; // next group start
  }

  // Frame out file and compute pharmacy grouping
  const columnCount = worksheet.actualColumnCount;
  const rowCount = worksheet.actualRowCount;
  let mailOrderCol = 8;

  // Find "Mail order pharmacy" (it's written into row 3 for each plan column)
  for (let col = 8; col <= columnCount; col++) {
    const cell = worksheet.getRow(3).getCell(col);
    const cellText = getCellString(cell).slice(0, 100);
    if (cellText === 'Mail order pharmacy') {
      mailOrderCol = col - 7;
      break;
    }
  }
  console.log(`${mailOrderCol} Pharmacies Detected.`);

  let pharmacyCounter = 1;

  // Compare retail pharmacies against mail order value and highlight 3x cases
  for (let rowNum = 4; rowNum <= rowCount; ++rowNum) {
    for (let colNum = 8; colNum <= columnCount; ++colNum) {
      if ((pharmacyCounter % mailOrderCol) == 0 && colNum !== 8) {
        // Add style border
        worksheet.getColumn(colNum).border = {
          right: { style: 'medium' }
        };

        // mail order value in this group
        const mailCell = worksheet.getRow(rowNum).getCell(colNum);
        const mailValue = toNumberish(getCellString(mailCell), 0);

        // walk backward for each pharmacy in the group and compare
        for (let retroNum = 1; retroNum < mailOrderCol; ++retroNum) {
          const pharmCell = worksheet.getRow(rowNum).getCell(colNum - retroNum);
          const pharmValue = toNumberish(getCellString(pharmCell), 0);

          if (pharmValue >= (mailValue * 3)) {
            pharmCell.fill = {
              type: 'pattern',
              pattern: 'solid',
              fgColor: { argb: 'FFFB00' }
            };
          }
        }
      }
      pharmacyCounter++;
    }
  }

  // Convert numeric-looking values to numbers with currency format â€” but never write NaN
  for (let rowNum = 4; rowNum <= rowCount; ++rowNum) {
    for (let colNum = 8; colNum <= columnCount; ++colNum) {
      const cell = worksheet.getRow(rowNum).getCell(colNum);
      const num = toNumberish(getCellString(cell), NaN);
      if (Number.isFinite(num)) {
        cell.value = num;
        cell.numFmt = '"$"#,##0.00';
      }
      // else leave as-is (text/blank)
    }
  }

  // final formatting on row 3
  worksheet.getRow(3).border = {
    top: { style: 'medium' },
    left: { style: 'medium' },
    bottom: { style: 'medium' },
    right: { style: 'medium' }
  };

  await workbook.xlsx.writeFile(xlfileName);
  return xlfileName;
}
