import * as fs from 'fs';
import * as path from 'path';
import * as glob from 'glob';
import * as os from 'os';
import { readCsv } from './fileManager';
const csv = require('csvtojson');
const Exceljs = require('exceljs');

export async function combineAndExport(fullPathOut) {
    const grps = await getFilePathGroups(fullPathOut);
    // For each zip grouping (i.e., each zipcode),
    // files are combined and written as one flat csv file per zip
    for (const g of Object.keys(grps)) {
        let flattenedZipDataObjects = await flattenFileGroup(grps[g]);
        let flatFilePath = await writeToFile(g, flattenedZipDataObjects);
        let fileName = g;
        let zip = fileName.split("_")[0];
        await outputToExcel(fullPathOut, fileName, flatFilePath, zip, flattenedZipDataObjects);
    }
}

export function testHeaders(flattenedZipDataObjects) {
    const lengths = flattenedZipDataObjects.map(obj => obj.length).flat();
    const distinctLengths = new Set(lengths);
    if (distinctLengths.size !== 1) {
        throw 'Unexpected plans and pharmacy counts found. Some drugs may have missing drug costs for a plan or pharmacy.';
    }
    const distinctHeaders = new Set();
    flattenedZipDataObjects.forEach(obj => distinctHeaders.add(obj.map(row => row[0]).join(',')));
    if (distinctHeaders.size !== 1) {
        throw 'Unexpected set of headers found. Some drugs may have missing drug costs for a plan or pharmacy.';
    }
}

export async function writeToFile(fileName, flattenedZipDataObjects) {
    const reportFile = path.join(__dirname, `../../../output/${fileName}_flat.csv`);
    console.log(`Working on file: ${fileName}`);
    try {
        fs.unlinkSync(reportFile);
    } catch (e) {
        // Ignore if the file doesn't exist
    }
    
    // testHeaders(flattenedZipDataObjects)

    // Build header row from the first 'row' of flattened data
    let header = `${flattenedZipDataObjects[0].map(row => row[0]).join(',')}\n`;
    let lines = [header];

    // Convert each flattened row into a CSV line
    for (const line of flattenedZipDataObjects) {
        let fullLine = line
            .map(row => {
                // Ensure row[1] is a string, remove commas
                let val = row[1] != null ? row[1].toString() : "";
                return val.replace(/,/g, '');
            })
            .join(',');
        lines.push(`${fullLine}\n`);
    }

    lines.forEach(ln => {
        fs.appendFileSync(reportFile, ln);
    });
    return reportFile;
}

/**
 * Groups the CSV files in `fullPathOut` by the zipcode prefix 
 * (everything before the first underscore).
 */
export async function getFilePathGroups(fullPathOut) {
    let pattern = `${fullPathOut}/*.csv`;
    const csvDataFiles = glob.sync(pattern);

    let testStr;
    let parts = [];
    let groupGlobs: string[] = [];
    csvDataFiles.forEach(nm => {
        parts = path.basename(nm).split('_');
        // if no indices provided, split on _ might yield something like "esrd.csv" 
        testStr = `${parts[0]}`;
        if (!groupGlobs.includes(testStr)) {
            groupGlobs.push(testStr);
        }
    });
    let groupedFiles: Record<string,string[]> = {};
    groupGlobs.forEach(glb => {
        pattern = `${fullPathOut}/${glb}*.csv`;
        // Sort & rank of the drug output
        groupedFiles[glb] = glob.sync(pattern)
            .sort((a, b) => a.localeCompare(b, undefined,{ numeric: true }));
    });

    console.log("Grouped Files Detected:");
    console.log(groupedFiles);
    return groupedFiles;
}

/**
 * For each zip group, read & sort the file data, flatten the rows for CSV/Excel
 */
export async function flattenFileGroup(fileGroupList) {
    let planIdMap = {};
    let zipGroupSortedObjects = await combineAndSortFileGroupData(fileGroupList);
    let flattenedZipData = flattenZipData(zipGroupSortedObjects, planIdMap);
    return flattenedZipData;
}

/**
 * Sort logic that includes mail-order logic and safe fallbacks.
 */
export async function combineAndSortFileGroupData(fileGroupList) {
    let zipData = [];
    for (const fileName of fileGroupList) {
        let fileData = await readCsv(fileName);
        zipData.push(...fileData);
    }

    // Safe string helper to avoid `undefined.localeCompare(...)` errors
    const safeStr = (val: any) => (typeof val === 'string' ? val : '');
    const safeNum = (val: any) => (typeof val === 'number' ? val : 0);

    // Sort by drugCategory, brandGenericFlag, rank, drugName, planId, 
    // plus mail-order logic
    zipData.sort(function(a, b) {
        let exceptions = ["Mail order pharmacy"];
        let indexA = exceptions.indexOf(safeStr(a.source));
        let indexB = exceptions.indexOf(safeStr(b.source));

        // Compare mail order if neither or both are exceptions
        let mail_order_calc = 0;
        if (indexA === -1 && indexB === -1) {
            // fallback to empty if a.source/b.source are not strings
            mail_order_calc = safeStr(a.source).toLowerCase()
                .localeCompare(safeStr(b.source).toLowerCase());
        } else {
            mail_order_calc = indexA - indexB; 
            // index will be -1 (doesn't occur), 0, or 1
        }
        return (
            safeStr(a.drugCategory).localeCompare(safeStr(b.drugCategory)) ||
            safeStr(a.brandGenericFlag).localeCompare(safeStr(b.brandGenericFlag)) ||
            (safeNum(a.rank) - safeNum(b.rank)) ||
            safeStr(a.drugName).localeCompare(safeStr(b.drugName)) ||
            safeStr(a.planId).localeCompare(safeStr(b.planId)) ||
            mail_order_calc
        );
    });
    
    return zipData;
}

/**
 * Flatten the sorted data into an array of arrays, each row representing 
 * a drug with multiple plan columns.
 */
export function flattenZipData(zipData, planIdMap) {
    let flattenedZipData = [];

    zipData.forEach(priceObjct => {
        // Fallbacks to avoid `undefined_undefined`
        let safePlanId = priceObjct.planId || "UnknownPlanId";
        let safePlanName = priceObjct.planName || "UnknownPlanName";
        let safeSource = priceObjct.source || "UnknownPharmacy";
        
        // Identify an existing row with same rank, category, drug, quantity
        let found = flattenedZipData.find(objct => 
            objct[0][1] == priceObjct.rank &&
            objct[1][1] == priceObjct.drugCategory &&
            objct[2][1] == priceObjct.drugName &&
            objct[3][1] == priceObjct.quantity
        );
        
        // Column header: "PlanId_PlanName_Source"
        let columnHeader = `${safePlanId}_${safePlanName}_${safeSource}`;
        
        if (found) {
            found.push([columnHeader, priceObjct.cost]);
        } else {
            let flattenedObj = [
                ['Rank', priceObjct.rank],
                ['Drug Category', priceObjct.drugCategory],
                ['Drug', priceObjct.drugName],
                ['Quantity', priceObjct.quantity],
                ['Refill Frequency', '30'],
                ['Package Option', priceObjct.packageOption],
                ['Brand or Generic', priceObjct.brandGenericFlag],
                [columnHeader, priceObjct.cost]
            ];
            flattenedZipData.push(flattenedObj);
        }
        planIdMap[columnHeader] = safePlanId;
    });    
    return flattenedZipData;
}

/**
 * Takes a file, flattens the data (formatted to be put in CSV).
 */
export async function flattenFile(filePath, orderOfPlans, orderOfSources, orderOfPlanIDs) {
    let currentDrug, currentCategory, currentRank, currentQty, currentRefillFreq, currentPackageOption, currentBorG;
    let planSourceObject = [];
    let planSourceObjects = [];
    let lines = [];
    
    await csv().fromFile(filePath).subscribe((lineData, rowNum) => {
        if (lineData.drugName != currentDrug) {
            if (rowNum > 0) {
                // add the completed line to the list
                lines.push(`${currentRank},${currentCategory},${currentDrug},${currentQty},${currentRefillFreq},${currentPackageOption},${currentBorG},${planSourceObjects.join()}\n`);
            }
            // reset loop state
            planSourceObject = [];
            planSourceObjects = [];
            currentDrug = lineData.drugName;
            currentRank = lineData.rank;
            currentCategory = lineData.drugCategory;
            currentQty = lineData.quantity;
            currentPackageOption = lineData.packageOption;
            currentBorG = lineData.brandGenericFlag;
            currentRefillFreq = "30";
        }
        if (!orderOfPlans.includes(lineData.planName)) {
            orderOfPlans.push(lineData.planName);
        }
        if (!orderOfSources.includes(lineData.source)) {
            orderOfSources.push(lineData.source);
        }
        if (!orderOfPlanIDs.includes(lineData.planId)) {
            orderOfPlanIDs.push(lineData.planId);
        }

        planSourceObject[orderOfSources.indexOf(lineData.source)] = lineData.cost;
        planSourceObjects[orderOfPlans.indexOf(lineData.planName)] = planSourceObject.slice();
    });
    
    // required for the last price line
    lines.push(`${currentRank},${currentCategory},${currentDrug},${currentQty},${currentRefillFreq},${currentPackageOption},${currentBorG},${planSourceObjects.join()}\n`);
    
    return lines;
}

/**
 * Writes the final Excel file, restoring 3-line plan columns and 
 * handling null values safely.
 */
export async function outputToExcel(fullPathOut, filename, flatFilePath, zipCode, flattenedZipDataObjects) {
    let xlfileName = path.join(fullPathOut, `${filename}_xl_file.xlsx`);

    // Open a workbook and add a sheet
    let workbook = new Exceljs.Workbook();
    let worksheet = workbook.addWorksheet("New Sheet");

    // Create columns from the first row of flattened data
    worksheet.columns = flattenedZipDataObjects[0].map(row => ({
        header: row[0],
        key: row[0]
    }));

    // Add 2 empty rows above header row
    worksheet.spliceRows(1, 0, []);
    worksheet.spliceRows(1, 0, []);

    // Insert all-row data
    const rows = [];
    flattenedZipDataObjects.forEach(row => {
        rows.push(row.map(data => data[1]));
    });
    worksheet.addRows(rows);

    // Default styling
    worksheet.properties.defaultColWidth = 10;
    worksheet.properties.defaultCellWidth = 10;
    worksheet.getRow(1).alignment = { vertical: 'middle', horizontal: 'left' };
    worksheet.getRow(2).alignment = { vertical: 'middle', horizontal: 'left' };
    worksheet.getRow(3).alignment = { vertical: 'middle', horizontal: 'left' };
    worksheet.getRow(1).height = 35;
    worksheet.getRow(2).height = 35;
    worksheet.getRow(3).height = 35;
    worksheet.getColumn(1).width = 8;
    worksheet.getColumn(2).width = 16;
    worksheet.getColumn(3).width = 35;
    worksheet.getColumn(4).width = 9;
    worksheet.getColumn(5).width = 16;
    worksheet.getColumn(6).width = 16;
    worksheet.getRow(1).font = { bold: true, size: 14 };
    worksheet.getRow(2).font = { bold: true, size: 12 };
    worksheet.getRow(3).font = { bold: true, size: 12 };
    worksheet.getRow(1).border = {
        top: { style: 'medium' },
        left: { style: 'medium' },
        bottom: { style: 'medium' },
        right: { style: 'medium' }
    };
    worksheet.getRow(2).border = {
        top: { style: 'medium' },
        left: { style: 'medium' },
        bottom: { style: 'medium' },
        right: { style: 'medium' }
    };
    worksheet.getColumn(7).border = {
        right: { style: 'medium' }
    };

    // Merge cells for Date
    const zipAndDateCellRange = 'A1:G2';
    worksheet.mergeCells(zipAndDateCellRange);
    const today = new Date();
    const dateString = `${today.getFullYear()}-${('0' + (today.getMonth() + 1)).slice(-2)}-${('0' + today.getDate()).slice(-2)}`;
    worksheet.getCell('A2').value = `Zip Code: ${zipCode} \n Report Date: ${dateString}`;
    
    // Split planName, planId, and Pharmacy into their own rows
    let firstPlanColumnNum = 7;
    for (let i = firstPlanColumnNum; i < worksheet._columns.length; i++) {
        let fullColumn = worksheet._columns[i];
        if (!fullColumn || !fullColumn.key) continue;

        // Key might be "S5617-214-0_Cigna Healthcare_Assurance Rx (PDP)_RITE AID..."
        let splitColNm = fullColumn.key.split('_');
        let planId = splitColNm[0] || "UnknownPlanId";
        let planName = splitColNm[1] || "UnknownPlanName";
        let pharmacyName = splitColNm[2] || "UnknownPharmacy";

        let thisColumn = worksheet.getColumn(fullColumn.key);

        // Row 1: Plan Name
        worksheet.getCell(1, thisColumn.number).value = `Plan Name: ${planName}`;
        worksheet.getCell(1, thisColumn.number).alignment = { vertical: 'middle', horizontal: 'center' };

        // Row 2: Plan Id
        worksheet.getCell(2, thisColumn.number).value = `Plan Id: ${planId}`;
        worksheet.getCell(2, thisColumn.number).alignment = { vertical: 'middle', horizontal: 'center' };

        // Row 3: Pharmacy
        worksheet.getCell(3, thisColumn.number).value = pharmacyName;
        worksheet.getCell(3, thisColumn.number).alignment = { vertical: 'middle', horizontal: 'center' };
        worksheet.getCell(3, thisColumn.number).width = 30;
    }

    // Merge row 1 and row 2 for each plan chunk
    firstPlanColumnNum = 8;
    let mergeSpan = 7;
    let currentColumnNum = worksheet.getCell(1, firstPlanColumnNum)._column._number;
    let lastColumnNumber = worksheet._columns[worksheet._columns.length-1]._number;
    while (currentColumnNum + mergeSpan <= lastColumnNumber) {
        worksheet.mergeCells(1, currentColumnNum, 1, currentColumnNum + mergeSpan);
        worksheet.mergeCells(2, currentColumnNum, 2, currentColumnNum + mergeSpan);
        currentColumnNum = currentColumnNum + mergeSpan + 1; // next cell column number
    }

    // Frame out file to see how many rows/columns
    const columnCount = worksheet.actualColumnCount;
    const rowCount = worksheet.actualRowCount;
    let mailOrderCol = 8;

    // Safely check for mail-order column in row 3
    for (let col = 8; col <= columnCount; col++) {
        let cellVal = worksheet.getCell(worksheet.getRow(3).getCell(col)._address).value;
        let safeVal = typeof cellVal === 'string' ? cellVal : "";
        let cellText = safeVal.substring(0, 100);

        if (cellText === 'Mail order pharmacy') {
            mailOrderCol = col - 7;
            break;
        }
    }

    console.log(`${mailOrderCol} Pharmacies Detected.`);
    let pharmacyCounter = 1;

    for (let rowNum = 4; rowNum <= rowCount; ++rowNum) {
        for (let colNum = 8; colNum <= columnCount; ++colNum) {
            if ((pharmacyCounter % mailOrderCol) === 0 && colNum !== 8) {
                // Add style border on the right
                worksheet.getColumn(colNum).border = {
                    right: { style: 'medium' }
                };
                // Safely get the mail-order cell
                let cellVal = worksheet.getCell(worksheet.getRow(rowNum).getCell(colNum)._address).value;
                let mailText = (typeof cellVal === 'string') ? cellVal.substring(0, 100) : "0";
                let mailValue = parseFloat(mailText) || 0;

                // Compare each preceding pharmacy in this chunk
                for (let retroNum = 1; retroNum < mailOrderCol; ++retroNum) {
                    let pharmAddress = (worksheet.getRow(rowNum).getCell((colNum - retroNum))._address).toString();
                    let pharmVal = worksheet.getCell(pharmAddress).value;
                    let pharmText = (typeof pharmVal === 'string') ? pharmVal.substring(0, 100) : "0";
                    let pharmValue = parseFloat(pharmText) || 0;

                    // Highlight cell if >= 3x mail order cost
                    if (pharmValue >= (mailValue * 3)) {
                        worksheet.getCell(pharmAddress).fill = {
                            type: 'pattern',
                            pattern: 'solid',
                            fgColor: { argb: 'FFFB00' }
                        };
                    }
                }
            }
            pharmacyCounter++;
        }
    }

    // Convert each plan cell to a numeric format
    for (let rowNum = 4; rowNum <= rowCount; ++rowNum) {
        for (let colNum = 8; colNum <= columnCount; ++colNum) {
            let address = (worksheet.getRow(rowNum).getCell((colNum))._address).toString();
            let val = worksheet.getCell(address).value;

            let numeric = (typeof val === 'number') ? val : parseFloat(val) || 0;
            worksheet.getCell(address).value = numeric;
            worksheet.getCell(address).numFmt = '"$"#,##0.00';
        }
    }

    // Final formatting on row 3
    worksheet.getRow(3).border = {
        top: { style: 'medium' },
        left: { style: 'medium' },
        bottom: { style: 'medium' },
        right: { style: 'medium' }
    };

    await workbook.xlsx.writeFile(xlfileName);
    return xlfileName;
}
