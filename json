import { Page } from 'puppeteer';
import delay from '../utilities/delay';
import ScrapeContext from '../scrapeContext';
import { ActionStatus, EventNames, AbstractHandler, CSSSelectors } from '../types';

export default class PlanDetailsHandler extends AbstractHandler {

    brokenAction: EventNames = EventNames.GeneralError;
    okAction: EventNames = EventNames.OnPagePlans;

    public async doAction(currentPage: Page, scrapeContext: ScrapeContext): Promise<Page> {

        // wait and see for the pop up and close if found
        await currentPage.waitForSelector(CSSSelectors.closeQuestionaireResponsivePopup, {timeout:1500}).then(async d => {
            this.logger('Questionaire popup found. Closing...')
            // the eval page for element and click
            await currentPage.$eval(CSSSelectors.closeQuestionaireResponsivePopup, (element: HTMLElement) => element.click());
            this.logger(`Questionaire popup closed.`)
        }).catch(e => {
            this.logger('No Questionaire popup to close');
        })
       
        // Wait until plan details page is done calculating results
        await currentPage.waitForFunction(selector =>
            !document.querySelector(selector).textContent.includes("Calculating")
          , {timeout: 30000*2}, CSSSelectors.planDetailsCalculating
        ).catch(e => {
            this.logger(`Timed out waiting for plan Detail page to finish showing 'Calculating...' for drug costs.
                This usually means medicare return unauthorized on the drug costs endpoint. 
                We do not yet know a way around this.`)
        });

        // get the drug cost tables
        // wait for div to load before retrieving Elements
        await currentPage.waitForSelector(CSSSelectors.drugCostTablesColapsed);
        // get the list of cost sections elements
        let costSections = await currentPage.$$(CSSSelectors.drugCostTablesColapsed);
        // get the plan id
        const planId = scrapeContext.currentPlan.planID;

        // loop variables
        let pharmaNameContainer;
        let pharmaName;

        let drugCosts;
        let isExpandedButton;
        let isExpanded;

        let networkStatusContainer;
        let networkStatus;

        let priceObject;
        // loop through first and expand any pharmacy cost tables that are not expanded yet
        for(const costDiv of costSections) {
            // get the pharmacy name
            pharmaNameContainer = await costDiv.$('h4');
            pharmaName = await currentPage.evaluate(ele => ele.textContent, pharmaNameContainer);
            // check if the Collapsible table is open, and if not, click button to expand
            isExpandedButton = await costDiv.$('button');
            isExpanded = await isExpandedButton.evaluate(el => el.getAttribute('aria-expanded'))
            if(isExpanded !== 'true'){
                await isExpandedButton.evaluate(but => but.click());
                this.logger(`Expanding the cost table for : ${pharmaName}`)
            } else {
                this.logger(`Table already expanded for: ${pharmaName}`)
            }
        }
        // reread the cost tables again now that they are expanded
        await delay(500)
        await currentPage.waitForSelector(CSSSelectors.drugCostTablesExpanded);
        costSections = await currentPage.$$(CSSSelectors.drugCostTablesExpanded);
        // loop over pharmacy cost tables
        for (const costDiv of costSections) {

            // get the pharmacy name
            pharmaNameContainer = await costDiv.$('h4');
            pharmaName = await currentPage.evaluate(ele => ele.textContent, pharmaNameContainer);
            this.logger(`Scraping pharmacy table: ${pharmaName}...`)

            // get network status for this pharmacy
            networkStatusContainer = await costDiv.$('tr > th[id*=out_of_network_pharmacy]');
            networkStatus = networkStatusContainer ? 'OUT' : pharmaName === 'Mail order pharmacy'? '': 'IN'; 
            
            // get drug cost table data
            drugCosts = await costDiv.$$eval('tbody > tr', rows => Array.from(rows, row => {
                // get drugName from header and prices from table data
                let drugNameHeader = row.querySelector('th').childNodes[0]
                //get the prices from table data
                const drugPriceData = row.querySelectorAll('td');
                let costsTexts = Array.from(drugPriceData, row => row.innerText);
                // Rverse prices so we can push drugname to start of list
                // then reverse back to expected order
                // [drugName,retailCost,anotherCost, etc....]
                costsTexts = costsTexts.reverse()
                costsTexts.push(drugNameHeader.textContent.trim())
                costsTexts = costsTexts.reverse()
                return costsTexts 
            }));
            // if drugCosts are empty, raise an error because this shouldn't happen
            if (!drugCosts || drugCosts.length === 0 || drugCosts.every(cost => cost[0] === '' && cost[1] === '')) {
                throw this.brokenAction;
            } 
            // for each drug cost row, create a priceObject and push to the drugsPriceDetails list
            drugCosts.forEach(drugCostEntry=> {
                // get table drugname, retail cost, and then clean them
                let medicareDrugName = drugCostEntry[0];
                // replace all commas to avoid csv write issues and remove $ for number format
                // replace all '/A' with '-9999999999' to avoid writing issues
                let retailCost = (drugCostEntry[1].replace(/,/g, '')).substring(1).replace('/A','-9999999999')
                //retailCost = parseInt(retailCost)
                // skip row with the Mothly Totoals information
                if(medicareDrugName !== 'Monthly totals'){
                    // find the index of the existing scrapeObject, which contains our drug meta, by matching on the medicare drug name
                    // so we can map back from the table's drug name to our meta data about the drug (including rank, our drug readable name, etc.)
                    // First match on medicareDrug name, then check whether this drug has a price for this plan and pharmacy. 
                    // Return the first which does not have a price for this plan and pharmacy.
                    // This is to handle the case where we scrape the same drug for different quantities. 
                    // medicare.gov orders the drug table by drug name, then by order searched, since
                    // drugsPriceDetails is order by when drug was searched, we can assume that the first
                    // drug searched which does not have a pricedetail object for this plan and pharmacy, is the next 
                    // price detail list to insert on
                    let thisDrugIndex: number = scrapeContext.drugsPriceDetails.findIndex(
                        priceObject => priceObject.medicareDrugName.trim() === medicareDrugName.trim() && !priceObject.drugPrices.some(
                                priceDetail => priceDetail.planID === planId && priceDetail.source === pharmaName));
                    // if(thisDrugIndex === -1) {
                    //     this.logger(`There is a matche for the drugname: ${scrapeContext.drugsPriceDetails.some(priceObject => priceObject.medicareDrugName === medicareDrugName)}`)
                    //     this.logger(`There was a drug cost found for this plan and pharmacy ${scrapeContext.drugsPriceDetails.some(priceObject => priceObject.medicareDrugName === medicareDrugName && priceObject.drugPrices.some(priceDetail => priceDetail.planID === planId && priceDetail.source === pharmaName))}`)
                    // }
                    // create a price object 
                    priceObject = {
                        planID: `${scrapeContext.currentPlan.planID}`,
                        planName: `${scrapeContext.currentPlan.planName}`,
                        source: `${pharmaName}`,
                        networkStatus: `${networkStatus}`,
                        cost: `${retailCost}`
                    }
                    // push priceObject to this drug's price details list
                    if (thisDrugIndex !== -1) {
                        scrapeContext.drugsPriceDetails[thisDrugIndex].drugPrices.push(priceObject);
                        this.logger(`${scrapeContext.drugsPriceDetails[thisDrugIndex].ourDrugName.padEnd(75)}${(retailCost as string).padEnd(15)}${networkStatus}`);
                    } else {
                        const availableMappers = scrapeContext.drugsPriceDetails.map(entry => entry.medicareDrugName);
                        const availableMappersPrettyText = JSON.stringify(availableMappers, null, '\t');
                        this.logger(
                            `Failed to map the medicare drug name on the table to the drug we searched.
                            Current PlanName: ${scrapeContext.currentPlan.planName}
                            Current Pharmacy Table: ${pharmaName}
                            Table Drug Name: ${medicareDrugName}
                            Table Drug Price: ${retailCost}
                            Available Drug Names Searched: ${availableMappersPrettyText}`
                        );
                        throw this.brokenAction;
                    }
                }
                
            });
        }
        // find the index of this current plan in the planDetails object list
        const thisPlanIndex = scrapeContext.planDetails.findIndex(plan => plan === scrapeContext.currentPlan)
        // update its wasScraped state to true
        scrapeContext.planDetails[thisPlanIndex].wasScraped = true;
        this.logger(`${scrapeContext.currentPlan.planName} ${scrapeContext.currentPlan.planID} was scraped. Going back to the plans list.`)
        // reset the current Plan to null
        scrapeContext.currentPlan = undefined;
        this.okAction = EventNames.PlanListUrlIterate;

        return currentPage;
    }
    private checkIsExpanded(isOpenButton) : boolean{
        let isExpanded = isOpenButton.evaluate(el => el.getAttribute('aria-expanded'));
        return isExpanded === 'true';
    }
    protected async getStatus(currentPage: Page, scrapeContext: ScrapeContext): Promise<ActionStatus> {
        return ActionStatus.STATUS_OK;
    }

}
