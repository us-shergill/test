import puppeteer, { Page, Browser, BrowserContext } from 'puppeteer';
import * as fs from 'fs';

export default class PageManager {
    private isPageActive: boolean = false;
    private browser: Browser;
    private context: BrowserContext;
    private isHeadless: boolean;
    private page: Page;
    private viewportSize = { width: 1100, height: 800 };
    private logOutPath?: string;

    constructor(isHeadless: boolean | "new" = "new", logOutPath?: string) {
        this.isHeadless = isHeadless === "new" ? true : isHeadless;
        this.logOutPath = `${logOutPath}.log`;
    }

    private async initBrowser() {
        if (!this.isPageActive) {
            this.isPageActive = true;
            this.logger('launching new puppeteer');

            this.browser = await puppeteer.launch({
                headless: this.isHeadless,
                defaultViewport: this.viewportSize,
                args: [
                    '--enable-features=NetworkService',
                    '--no-sandbox',
                    '--disable-gpu',
                    '--incognito',
                    '--disable-extensions',
                    '--no-zygote',
                    '--disable-background-networking',
                    '--disable-default-apps',
                    '--disable-sync',
                    '--disable-setuid-sandbox',
                    '--disable-dev-shm-usage',
                    '--disable-accelerated-2d-canvas',
                    '--no-first-run',
                ]
            });

            this.context = await this.browser.createBrowserContext({
                ignoreHTTPSErrors: true
            });
        }
    }

    public async getPage(url: string) {
        this.logger('Initializing browser');
        await this.initBrowser();

        this.page = await this.context.newPage();

        await this.page.setExtraHTTPHeaders({
            'user-agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36',
            'upgrade-insecure-requests': '1',
            'accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8',
            'accept-encoding': 'gzip, deflate, br',
            'accept-language': 'en-US,en;q=0.9,en;q=0.8'
        });

        this.logger(`Navigating to url: ${url}`);
        await this.page.goto(url);
        return this.page;
    }

    public async closePage(page: Page) {
        await page.close();
    }

    public async closeBrowser() {
        await this.context.close();
        await this.browser.close();
    }

    public async wasBrowserKilled() {
        const procInfo = await this.browser.process();
        return !!procInfo.signalCode; // null if browser is still running
    }

    protected async logger(logString: string, logObject?: object, levelOne?: boolean, levelTwo?: boolean) {
        let timeStamp = '[' + new Date().toLocaleTimeString() + ']';
        let className = this.constructor.name;
        const logText = logObject
            ? '\x1b[36m%s\x1b[0m' + timeStamp + ` ${className.padEnd(28)}|  ` + logString + logObject
            : '\x1b[36m%s\x1b[0m' + timeStamp + ` ${className.padEnd(28)}|  ` + logString;

        console.log(logText);

        if (this.logOutPath) {
            if (fs.existsSync(this.logOutPath)) {
                fs.appendFileSync(this.logOutPath, '\n' + logText, 'utf8');
            } else {
                fs.writeFileSync(this.logOutPath, logText, 'utf8');
            }
        }
    }
}
