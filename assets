import * as fs from 'fs';
import * as path from 'path';
import * as glob from 'glob';
import { readCsv } from './fileManager';
const csv = require('csvtojson');
const Exceljs = require('exceljs');

export async function combineAndExport(fullPathOut) {
    const grps = await getFilePathGroups(fullPathOut);
    
    for (const g of Object.keys(grps)) {
        let flattenedZipDataObjects = await flattenFileGroup(grps[g]);
        let flatFilePath = await writeToFile(g, flattenedZipDataObjects);
        let fileName = g;
        let zip = fileName.split("_")[0];
        
        await outputToExcel(fullPathOut, fileName, flatFilePath, zip, flattenedZipDataObjects);
    }
}

export async function getFilePathGroups(fullPathOut) {
    let pattern = `${fullPathOut}/*.csv`;
    const csvDataFiles = glob.sync(pattern);

    let groupGlobs = [];
    let groupedFiles: Record<string, string[]> = {};

    csvDataFiles.forEach(nm => {
        let zipCode = path.basename(nm).split('_')[0]; 
        if (!groupGlobs.includes(zipCode)) {
            groupGlobs.push(zipCode);
        }
    });

    groupGlobs.forEach(glb => {
        pattern = `${fullPathOut}/${glb}*.csv`;
        groupedFiles[glb] = glob.sync(pattern).sort((a, b) => a.localeCompare(b, undefined, { numeric: true }));
    });

    console.log("Grouped Files Detected:", groupedFiles);
    return groupedFiles;
}

export async function flattenFileGroup(fileGroupList) {
    let zipGroupSortedObjects = await combineAndSortFileGroupData(fileGroupList);
    return flattenZipData(zipGroupSortedObjects);
}

export async function combineAndSortFileGroupData(fileGroupList) {
    let zipData = [];
    for (const fileName of fileGroupList) {
        let fileData = await readCsv(fileName);
        zipData.push(...fileData);
    }

    zipData.sort((a, b) => (
        a.drugCategory.localeCompare(b.drugCategory) ||
        a.brandGenericFlag.localeCompare(b.brandGenericFlag) ||
        a.rank - b.rank ||
        a.drugName.localeCompare(b.drugName) ||
        a.planId.localeCompare(b.planId)
    ));

    return zipData;
}

export function flattenZipData(zipData) {
    let flattenedZipData = [];
    
    zipData.forEach(priceObjct => {
        let found = flattenedZipData.find(objct => 
            objct[0][1] == priceObjct.rank &&
            objct[1][1] == priceObjct.drugCategory &&
            objct[2][1] == priceObjct.drugName &&
            objct[3][1] == priceObjct.quantity
        );

        if (found) {
            found.push([`${priceObjct.planId}_${priceObjct.planName}_${priceObjct.source}`, priceObjct.cost]);
        } else {
            flattenedZipData.push([
                ['Rank', priceObjct.rank],
                ['Drug Category', priceObjct.drugCategory],
                ['Drug', priceObjct.drugName],
                ['Quantity', priceObjct.quantity],
                ['Refill Frequency', '30'],
                ['Package Option', priceObjct.packageOption],
                ['Brand or Generic', priceObjct.brandGenericFlag],
                [`${priceObjct.planId}_${priceObjct.planName}_${priceObjct.source}`, priceObjct.cost]
            ]);
        }
    });

    return flattenedZipData;
}

export async function writeToFile(fileName, flattenedZipDataObjects) {
    const reportFile = path.join(__dirname, `../../../output/${fileName}_flat.csv`);
    console.log(`Working on file: ${fileName}`);

    try { fs.unlinkSync(reportFile); } catch (e) {}

    let lines = [
        `${flattenedZipDataObjects[0].map(row => row[0]).join(',')}\n`
    ];

    flattenedZipDataObjects.forEach(line => {
        let fullLine = line.map(row => row[1]?.toString().replace(/,/g, '') || "").join(',');
        lines.push(`${fullLine}\n`);
    });

    lines.forEach(ln => fs.appendFileSync(reportFile, ln));

    return reportFile;
}

export async function outputToExcel(fullPathOut, filename, flatFilePath, zipCode, flattenedZipDataObjects) {
    let xlfileName = path.join(fullPathOut, `${filename}_xl_file.xlsx`);
    let workbook = new Exceljs.Workbook();
    let worksheet = workbook.addWorksheet("New Sheet");

    worksheet.columns = flattenedZipDataObjects[0].map(row => ({ header: row[0], key: row[0] }));
    worksheet.addRows(flattenedZipDataObjects.map(row => row.map(data => data[1])));

    const columnCount = worksheet.actualColumnCount;
    const rowCount = worksheet.actualRowCount;

    let mailOrderCol = 8;
    for (let col = 8; col <= columnCount; col++) {
        let cellValue = worksheet.getCell(worksheet.getRow(3).getCell(col)._address).value;
        let cellText = (cellValue && typeof cellValue === "string") ? cellValue.substring(0, 100) : "";

        if (cellText === 'Mail order pharmacy') {
            mailOrderCol = col - 7;
            break;
        }
    }

    console.log(`${mailOrderCol} Pharmacies Detected.`);
    
    for (let rowNum = 4; rowNum <= rowCount; ++rowNum) {
        for (let colNum = 8; colNum <= columnCount; ++colNum) {
            let cellValue = worksheet.getCell(worksheet.getRow(rowNum).getCell(colNum)._address).value;
            let mailText = (cellValue && typeof cellValue === "string") ? cellValue.substring(0, 100) : "0";
            let mailValue = parseFloat(mailText) || 0;

            for (let retroNum = 1; retroNum < mailOrderCol; ++retroNum) {
                let pharmAddress = worksheet.getRow(rowNum).getCell((colNum - retroNum))._address;
                let pharmCellValue = worksheet.getCell(pharmAddress).value;
                let pharmText = (pharmCellValue && typeof pharmCellValue === "string") ? pharmCellValue.substring(0, 100) : "0";
                let pharmValue = parseFloat(pharmText) || 0;

                if (pharmValue >= (mailValue * 3)) {
                    worksheet.getCell(pharmAddress).fill = {
                        type: 'pattern',
                        pattern: 'solid',
                        fgColor: { argb: 'FFFB00' }
                    };
                }
            }
        }
    }

    for (let rowNum = 4; rowNum <= rowCount; ++rowNum) {
        for (let colNum = 8; colNum <= columnCount; ++colNum) {
            let address = worksheet.getRow(rowNum).getCell(colNum)._address;
            let value = parseFloat(worksheet.getCell(address).value) || 0;
            worksheet.getCell(address).value = value;
            worksheet.getCell(address).numFmt = '"$"#,##0.00';
        }
    }

    await workbook.xlsx.writeFile(xlfileName);
    return xlfileName;
}
